[
["index.html", "Data Manipulation with SQL Preface", " Data Manipulation with SQL Qiushi Yan 2020-07-28 Preface This document covers essential SQL skills for data manipulation, with a focus on DQL (Data Query Language, always starts with SELECT). Quries will typically be interpreted with the PostgreSQL dialect in knitr’s sql engine. I include dplyr code when there could be some interesting comparison between these two tools sharing similar philosophy. Before each chapter, the following command is automatically evaluated: library(RPostgreSQL) library(DBI) con &lt;- dbConnect(dbDriver(&#39;PostgreSQL&#39;), # SQL engine dbname = dbname, # database name host = &quot;localhost&quot;, # either localhost or a database url port = 5432, # the defualt port user = user, # username password = password) # password By default, SELECT queries will display the first 10 records of their results within the document, in other words LIMIT 10 is appended to each query, this is controlled via knitr::opts_knit$set(sql.max.print = 10). References include: Coursera course Analyzing Big Data with SQL SQL Tutorial Practical SQL A Beginner’s Guide to Storytelling with Data (DeBarros 2018) SQL for Data Analytics: Perform fast and efficient data analysis with the power of SQL (Malik, Goldwasser, and Johnston 2019) "],
["basic-query.html", "Chapter 1 Basic query", " Chapter 1 Basic query SELECT * FROM us_counties_2010 Table 1.1: Displaying records 1 - 10 geo_name state_us_abbreviation summary_level region division state_fips county_fips area_land area_water population_count_100_percent housing_unit_count_100_percent internal_point_lat internal_point_lon p0010001 p0010002 p0010003 p0010004 p0010005 p0010006 p0010007 p0010008 p0010009 p0010010 p0010011 p0010012 p0010013 p0010014 p0010015 p0010016 p0010017 p0010018 p0010019 p0010020 p0010021 p0010022 p0010023 p0010024 p0010025 p0010026 p0010047 p0010063 p0010070 p0020001 p0020002 p0020003 p0020004 p0020005 p0020006 p0020007 p0020008 p0020009 p0020010 p0020011 p0020012 p0020028 p0020049 p0020065 p0020072 p0030001 p0030002 p0030003 p0030004 p0030005 p0030006 p0030007 p0030008 p0030009 p0030010 p0030026 p0030047 p0030063 p0030070 p0040001 p0040002 p0040003 p0040004 p0040005 p0040006 p0040007 p0040008 p0040009 p0040010 p0040011 p0040012 p0040028 p0040049 p0040065 p0040072 h0010001 h0010002 h0010003 Autauga County AL 050 3 6 01 001 1539582278 25775735 54571 22135 32.5 -86.6 54571 53702 42855 9643 232 474 32 466 869 814 219 262 177 11 50 32 19 9 16 0 0 5 5 8 1 49 6 0 0 54571 1310 53261 52500 42154 9595 217 467 22 45 761 719 36 6 0 0 39958 39530 31910 6767 180 346 23 304 428 404 22 2 0 0 39958 828 39130 38746 31461 6738 169 341 15 22 384 363 19 2 0 0 22135 20221 1914 Baldwin County AL 050 3 6 01 003 4117521611 1133190229 182265 104061 30.7 -87.7 182265 179542 156153 17105 1216 1348 89 3631 2723 2583 658 1035 336 35 311 63 34 7 38 12 0 15 11 14 14 128 11 1 0 182265 7992 174273 171976 152200 16966 1146 1340 79 245 2297 2205 87 5 0 0 140367 138905 122238 12272 923 1002 70 2400 1462 1398 60 3 1 0 140367 5186 135181 133937 119671 12193 876 994 62 141 1244 1198 46 0 0 0 104061 73180 30881 Barbour County AL 050 3 6 01 005 2291818968 50864716 27457 11829 31.9 -85.4 27457 27199 13180 12875 114 107 29 894 258 254 76 49 7 2 34 54 2 4 7 0 1 2 1 5 10 3 0 0 1 27457 1387 26070 25861 12837 12820 60 107 24 13 209 206 2 0 0 1 21442 21275 10855 9647 86 80 24 583 167 163 3 0 0 1 21442 925 20517 20382 10624 9605 47 80 21 5 135 132 2 0 0 1 11829 9820 2009 Bibb County AL 050 3 6 01 007 1612480789 9289057 22915 8981 33.0 -87.1 22915 22712 17381 5047 64 22 13 185 203 195 50 77 16 3 16 9 13 5 4 0 0 2 0 0 0 8 0 0 0 22915 406 22509 22328 17191 5024 64 22 7 20 181 175 6 0 0 0 17714 17584 13403 3975 47 14 11 134 130 128 2 0 0 0 17714 310 17404 17284 13247 3963 47 14 5 8 120 119 1 0 0 0 8981 7953 1028 Blount County AL 050 3 6 01 009 1669961855 15157440 57322 23887 34.0 -86.6 57322 56638 53068 761 307 117 38 2347 684 662 112 330 74 8 102 12 2 0 6 3 0 2 4 7 0 21 1 0 0 57322 4626 52696 52129 50952 724 285 115 18 35 567 547 19 1 0 0 43216 42810 40515 549 227 91 23 1405 406 394 12 0 0 0 43216 2724 40492 40141 39285 524 212 89 14 17 351 341 10 0 0 0 23887 21578 2309 Bullock County AL 050 3 6 01 011 1613056905 6056528 10914 4493 32.1 -85.7 10914 10828 2507 7666 23 20 43 569 86 82 12 28 3 0 3 8 5 2 9 0 0 3 0 0 9 4 0 0 0 10914 777 10137 10078 2392 7637 20 20 4 5 59 56 3 0 0 0 8484 8432 2164 5838 21 17 31 361 52 49 3 0 0 0 8484 485 7999 7963 2102 5821 18 17 3 2 36 33 3 0 0 0 4493 3745 748 Butler County AL 050 3 6 01 013 2011976894 2726814 20947 9964 31.8 -86.7 20947 20786 11399 9095 60 177 7 48 161 153 58 41 17 1 13 10 4 3 3 0 0 3 0 0 0 8 0 0 0 20947 191 20756 20614 11324 9047 59 174 7 3 142 139 3 0 0 0 15891 15811 9109 6504 44 119 3 32 80 76 4 0 0 0 15891 130 15761 15694 9062 6468 43 117 3 1 67 65 2 0 0 0 9964 8491 1473 Calhoun County AL 050 3 6 01 015 1569189995 16624267 118572 53289 33.8 -85.8 118572 116597 88840 24382 540 845 96 1894 1975 1848 676 520 223 49 143 67 48 20 46 8 2 4 17 17 8 109 17 0 1 118572 3893 114679 112975 87285 24177 480 830 94 109 1704 1602 93 8 0 1 91446 90441 70313 17746 451 665 70 1196 1005 939 62 3 0 1 91446 2473 88973 88088 69294 17621 409 653 69 42 885 826 56 2 0 1 53289 47331 5958 Chambers County AL 050 3 6 01 017 1545009282 17048142 34215 17004 32.9 -85.4 34215 33830 20112 13257 69 168 10 214 385 373 162 101 27 1 37 11 10 0 22 0 0 0 0 1 1 11 1 0 0 34215 536 33679 33352 19893 13206 57 166 7 23 327 317 10 0 0 0 26512 26332 16182 9798 58 138 6 150 180 173 6 1 0 0 26512 364 26148 25995 16037 9761 48 136 3 10 153 148 5 0 0 0 17004 13933 3071 Cherokee County AL 050 3 6 01 019 1434075952 119858898 25989 16267 34.1 -85.7 25989 25602 24081 1208 135 54 1 123 387 376 94 206 19 12 35 9 0 0 0 0 0 0 0 1 0 11 0 0 0 25989 320 25669 25322 23929 1206 122 49 1 15 347 337 10 0 0 0 20423 20216 19090 909 105 35 1 76 207 202 5 0 0 0 20423 171 20252 20051 19005 909 99 32 1 5 201 196 5 0 0 0 16267 10626 5641 "],
["filtering.html", "Chapter 2 Filtering ", " Chapter 2 Filtering "],
["the-where-clause.html", "2.1 The WHERE clause", " 2.1 The WHERE clause "],
["operators.html", "2.2 Operators", " 2.2 Operators 2.2.1 Comparison operators 2.2.2 Logical operators Logical operators enable users to combine multiple boolean expressions. Binary operators AND and OR Unary operator NOT Be mindful of order of operators: NOT (first), AND (second), OR (third). One workaround is to use parenthesis () to indicate order of operations, this makes queries more readable. SELECT CAST (region as varchar(5)), COALESCE(summary_level, &#39;0&#39;), avg(p0010001) AS pop FROM us_counties_2010 GROUP BY (region, summary_level) Table 1.1: 4 records region coalesce pop 3 050 80503 4 050 160593 2 050 63438 1 050 254918 "],
["other-relational-operators.html", "2.3 Other relational operators", " 2.3 Other relational operators "],
["missing-values.html", "2.4 Missing values", " 2.4 Missing values Any rows in which the expression in the WHERE clause evaluate to false and any rows in which it evaluates to NULL, are filtered out excluded from the result set. Knitr’s SQL engine displays NULL as NA in the resulting table, but remember in databases this is actually NULL. How many different games in the inventory table are located in Aisle 3 of the Dicey shop? SELECT DISTINCT game FROM inventory WHERE shop = &#39;Dicey&#39; AND aisle = 3 Table 2.1: 1 records game Monopoly The answer is at least 1. Since the row representing the game Clue in the shop Dicey has a missing value in the aisle column. You cannot rule out the possibility that this game is in Aisle 3. SELECT * FROM inventory WHERE aisle IS NULL Table 2.2: 1 records shop game qty aisle price Dicey Clue 3 NA 9.99 What if you wanted to write a WHERE clause to filter out the office in Illinois in the offices table, to return the three offices that are not in Illinois. You might try to write a WHERE clause like WHERE state_province not &lt;&gt; 'Illinois'. But this returns only two rows. SELECT * FROM offices WHERE state_province &lt;&gt; &#39;Illinois&#39; Table 2.3: 2 records office_id city state_province country a Istanbul Istanbul tr c Rosario Santa Fe ar Though row representing the Singapore office is not in the result set. That’s because the state province value in that row is null, and “null not equal to Illinois” evaluates to null. So that row is excluded from the results set SELECT * FROM offices Table 2.4: 4 records office_id city state_province country a Istanbul Istanbul tr b Chicago Illinois us c Rosario Santa Fe ar d Singapore NA sg But in this case, you know from context that this NULL value doesn’t mean unknown, it means not applicable because Singapore does not have states or provinces. This is the type of situation where the IS DISTINCT FROM operator is useful. SELECT * FROM offices WHERE state_province IS DISTINCT FROM &#39;Illinois&#39; Table 2.5: 3 records office_id city state_province country a Istanbul Istanbul tr c Rosario Santa Fe ar d Singapore NA sg The IS DISTINCT FROM operator is like the not equals operator !=, but it treats NULL values and non NULL values as explicitly unequal. Whenever the operand on one side is NULL and the operand on the other side is not NULL, it evaluates to true. There is also a version of this operator that negates the result of the comparison, IS NOT DISTINCT FROM. This is like the equals operator, except when it compares a NULL value with a non-null value, it returns false instead of NULL. And when it compares two NULL values it returns true instead of NULL. This shorthand notation for IS NOT DISTINCT FROM, &lt;=&gt; is supported by Hive, Impala, and MySQL. 2.4.1 Conditional functions if CASE nullif ifnull coalesce SELECT DISTINCT color FROM crayons WHERE red = 205 Table 2.6: 4 records color Mahogany Silver Antique Brass Wisteria "],
["aggregating.html", "Chapter 3 Aggregating", " Chapter 3 Aggregating In each of the examples, the expression aggregates over all the rows, and returns a single row. That’s what makes these expressions aggregate expressions. They can combine values from multiple rows, aggregating them together. These are different from the expressions earlier like round, strsub , which operate independently on the values in each row. Those are called non-aggregate expressions or scalar expressions. They return one value per row. One need to be careful about mixing aggregate and scalar operations. You can use aggregate and scalar operations together in an expression as in the following examples. SELECT round(AVG(salary), 1) AS avg_salary FROM employees Table 1.1: 1 records avg_salary 37081 SELECT SUM(salary * 0.5) AS avg_half_salary FROM employees Table 2.1: 1 records avg_half_salary 92702 Unfortunately, there are also invalid mix of aggregation expression and scalar expressions. -- not run SELECT salary - AVG(salary) FROM employees This query will throw an error message like “employees.salary must appear in the GROUP BY clause or be used in an aggregate function”. For R users, this may be a bit confusing, since similar dplyr expresisons work just fine: library(dplyr) employees &lt;- readr::read_csv(&quot;data/employees.csv&quot;) employees %&gt;% mutate(difference = salary - mean(salary)) #&gt; # A tibble: 5 x 6 #&gt; empl_id first_name last_name salary office_id difference #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 1 Ambrosio Rojas 25784 c -11297. #&gt; 2 2 Val Snyder 37506 e 425. #&gt; 3 3 Virginia Levitt 54523 b 17442. #&gt; 4 4 Sabahattin Tilki 28060 a -9021. #&gt; 5 5 Lujza Csizmadia 39530 b 2449. For now, the workaround is to use subqueries. Later we will see another solution using window functions in Chapter ??. SELECT salary - (SELECT AVG(salary) FROM employees) AS difference FROM employees Table 2.4: 5 records difference -11297 425 17442 -9021 2449 Also, you cannot use scalar and aggregate expressions. For example, this query has two items in the SELECT list. -- not run SELECT first_name, sum(salary) FROM employees The first is just the column reference first name, that evaluates as a scalar expression. It returns a value for each row in the employees table. The second is the aggregate expression, sum salary. That returns just one row that aggregates all the salary values in the employees table. We cannot use both of these types of expressions together in one select list. SELECT red, green, blue, greatest(red, green, blue) FROM crayons Table 2.6: Displaying records 1 - 10 red green blue greatest 239 219 197 239 205 149 117 205 253 217 181 253 120 219 226 226 135 169 107 169 255 164 116 255 250 231 181 250 159 129 112 159 253 124 110 253 35 35 35 35 "],
["the-group-by-clause-.html", "3.1 The GROUP BY clause.", " 3.1 The GROUP BY clause. No surprise, the GROUP BY clasue works hand in hand with aggregate expressions, as group_by() does with summarize() in dplyr. SELECT min_age, COUNT(*) FROM games WHERE list_price &gt; 10 GROUP BY min_age; Table 3.1: 2 records min_age count 8 2 10 1 Grouping expressions using column aliases, availabe in PostgreSQL, Impala, Mysql. SELECT list_price &lt; 10 AS low_price, count(*) FROM games GROUP BY low_price Table 3.2: 2 records low_price count FALSE 3 TRUE 2 SELECT list_price &lt; 10, COUNT(*) FROM games GROUP BY list_price &lt; 10; Table 3.3: 2 records ?column? count FALSE 3 TRUE 2 SELECT list_price &gt; 20 AS over_20, max_players, COUNT(*) FROM games GROUP BY over_20, max_players; Table 3.4: 3 records over_20 max_players count FALSE 4 2 FALSE 6 2 TRUE 5 1 SELECT shop, SUM((price IS NULL)::int), count(*) FROM inventory GROUP BY shop Table 3.5: 2 records shop sum count Board ’Em 1 3 Dicey 0 2 "],
["null-values-in-aggregation.html", "3.2 NULL values in aggregation", " 3.2 NULL values in aggregation The COUNT function was designed to be consistent with these other aggregate functions except in the case where you use COUNT(*). So the general rule is that aggregate functions ignore NULL values, and the one exception to that rule is when you use COUNT(*). With some SQL engines, you can specify more than one column reference or expression after the DISTINCT keyword in the COUNT function. This returns the number of unique combinations of the specified columns that exist in the data. This works in Hive, Impala, and MySQL, but not in PostgreSQL. -- this won&#39;t work in PostgreSQL SELECT COUNT(DISTINCT red, green, blue) FROM crayons Also, with some SQL engines, you can use more than one COUNT(DISTINCT) in a SELECT list, like in this example which uses the crayons table. -- PostgreSQL allows for multiple COUNT(DISTINCT) in one select list SELECT pack, COUNT(DISTINCT red) AS red_count, COUNT(DISTINCT green) AS green_count, COUNT(DISTINCT blue) AS blue_count FROM crayons GROUP BY pack Table 3.6: 9 records pack red_count green_count blue_count 4 4 4 4 8 4 4 4 16 6 8 7 24 7 8 8 32 8 8 8 48 14 16 14 64 15 15 16 96 21 27 26 120 21 22 24 Here, the COUNT function is used three separate times in the SELECT list and the DISTINCT keyword is included in all three. So the result set has three columns giving the number of unique values in the red column, the number of unique values in the green column, and the number of unique values in the blue column. But with some other SQL engines including Impala, you are limited to only oneCOUNT(DISTINCT) per SELECT list. "],
["the-having-clause.html", "3.3 The HAVING clause", " 3.3 The HAVING clause The WHERE clause is used before GROUP BY , because it makes more sense. The filter specified in the WHERE clause is used before grouping. After grouping, you can have a HAVING clause, which is similar to WHERE , except you can filter by aggregate values as well. Often you’ll want to include the aggregate expression that you use in the HAVING clause in the SELECT list as well. So you can see the values in the column you filtered by. In this example, the query filters by sum of price times quantity. It’s good to see those sum of price times quantity values for the rows that are included in the result set. So some of price times quantity is also used in the SELECT list. SELECT shop, sum(qty * price) FROM inventory GROUP BY shop HAVING sum(qty * price) &gt; 300 Table 3.7: 1 records shop sum Board ’Em 380 But it’s inconvenient to have to repeat the same expression in these two different places. So some SQL engines provide a shortcut that you can use to avoid this repetition. With some SQL engines, you can specify the aggregate expression in the SELECT list, give it an alias, and then use that alias in the HAVING clause. That way you do not need to repeat the aggregate expression twice. This shortcut works with Impala, Hive, and MySQL, but not with PostgreSQL and some other SQL engines. If you’re using a different SQL engine, trying to see if it works. -- this does not work in PostgreSQL SELECT shop, sum(qty * price) AS total FROM inventory GROUP BY shop HAVING total &gt; 300 "],
["windows-functions.html", "Chapter 4 Windows functions", " Chapter 4 Windows functions SELECT office_id, first_name, salary, sum(salary) OVER (PARTITION BY office_id ORDER BY salary) AS avg_salary FROM employees ORDER BY office_id Table 1.1: 5 records office_id first_name salary avg_salary a Sabahattin 28060 28060 b Lujza 39530 39530 b Virginia 54523 94053 c Ambrosio 25784 25784 e Val 37506 37506 SELECT * FROM customers Table 2.1: 4 records cust_id name country a Arfa pk b Brendon us c Chiyo ja d Dikembe ug "],
["statisticcs-with-window-functions.html", "4.1 Statisticcs with window functions", " 4.1 Statisticcs with window functions "],
["references.html", "References", " References DeBarros, A. 2018. Practical Sql: A Beginner’s Guide to Storytelling with Data. No Starch Press. https://books.google.com/books?id=xbbRAQAACAAJ. Malik, U., M. Goldwasser, and B. Johnston. 2019. SQL for Data Analytics: Perform Fast and Efficient Data Analysis with the Power of Sql. Packt Publishing. https://books.google.com/books?id=jfAXxQEACAAJ. "]
]
